{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Line } from 'vue-chartjs';\nexport default {\n  name: 'CodingChallenge',\n  extends: Line,\n  props: {\n    optionsData: {\n      type: Array,\n      required: true\n    }\n  },\n  data() {\n    return {\n      maxProfit: 0,\n      maxLoss: 0,\n      breakEvenPoints: []\n    };\n  },\n  mounted() {\n    this.calculateRiskReward();\n  },\n  methods: {\n    calculateRiskReward() {\n      // Implement logic to calculate max profit, max loss, and break even points\n      let totalPremiumReceived = 0;\n      let totalPremiumPaid = 0;\n      this.optionsData.forEach(option => {\n        if (option.longShort === 'long') {\n          totalPremiumPaid += option.ask;\n        } else if (option.longShort === 'short') {\n          totalPremiumReceived += option.bid;\n        }\n      });\n      this.maxProfit = totalPremiumReceived.toFixed(2);\n      this.maxLoss = totalPremiumPaid.toFixed(2);\n\n      // Example break even point calculation (replace with your strategy logic)\n      this.breakEvenPoints = [this.optionsData[0].strikePrice - this.optionsData[0].ask, this.optionsData[0].strikePrice + this.optionsData[0].bid];\n\n      // Render the graph after calculations\n      this.renderGraph();\n    },\n    renderGraph() {\n      this.renderChart({\n        labels: ['Underlying Price'],\n        datasets: [{\n          label: 'Profit/Loss',\n          borderColor: 'rgba(75, 192, 192, 1)',\n          borderWidth: 2,\n          pointBackgroundColor: 'rgba(75, 192, 192, 1)',\n          pointBorderColor: '#fff',\n          pointBorderWidth: 1,\n          pointRadius: 3,\n          pointHoverRadius: 5,\n          data: this.calculateProfitLoss()\n        }]\n      }, {\n        responsive: true,\n        maintainAspectRatio: false,\n        scales: {\n          xAxes: [{\n            scaleLabel: {\n              display: true,\n              labelString: 'Underlying Price'\n            },\n            ticks: {\n              beginAtZero: false\n            }\n          }],\n          yAxes: [{\n            scaleLabel: {\n              display: true,\n              labelString: 'Profit/Loss'\n            },\n            ticks: {\n              beginAtZero: false\n            }\n          }]\n        }\n      });\n    },\n    calculateProfitLoss() {\n      // Example logic to calculate profit/loss at different prices\n      const underlyingPrices = [90, 95, 100, 105, 110, 115, 120]; // Example underlying prices\n      const profitLoss = [];\n      underlyingPrices.forEach(price => {\n        let totalProfitLoss = 0;\n        this.optionsData.forEach(option => {\n          if (option.type === 'Call') {\n            if (option.longShort === 'long') {\n              totalProfitLoss -= Math.max(0, price - option.strikePrice) - option.ask;\n            } else if (option.longShort === 'short') {\n              totalProfitLoss += Math.max(0, price - option.strikePrice) - option.bid;\n            }\n          } else if (option.type === 'Put') {\n            if (option.longShort === 'long') {\n              totalProfitLoss += Math.max(0, option.strikePrice - price) - option.ask;\n            } else if (option.longShort === 'short') {\n              totalProfitLoss -= Math.max(0, option.strikePrice - price) - option.bid;\n            }\n          }\n        });\n        profitLoss.push(totalProfitLoss.toFixed(2));\n      });\n      return profitLoss;\n    }\n  }\n};","map":{"version":3,"names":["Line","name","extends","props","optionsData","type","Array","required","data","maxProfit","maxLoss","breakEvenPoints","mounted","calculateRiskReward","methods","totalPremiumReceived","totalPremiumPaid","forEach","option","longShort","ask","bid","toFixed","strikePrice","renderGraph","renderChart","labels","datasets","label","borderColor","borderWidth","pointBackgroundColor","pointBorderColor","pointBorderWidth","pointRadius","pointHoverRadius","calculateProfitLoss","responsive","maintainAspectRatio","scales","xAxes","scaleLabel","display","labelString","ticks","beginAtZero","yAxes","underlyingPrices","profitLoss","price","totalProfitLoss","Math","max","push"],"sources":["src/components/CodingChallenge.vue"],"sourcesContent":["<template>\n  <div class=\"coding-challenge\">\n    <h2>Options Strategy Risk & Reward Analysis</h2>\n    <div class=\"graph-container\">\n      <canvas id=\"strategyGraph\" ref=\"strategyGraph\"></canvas>\n    </div>\n    <div class=\"strategy-details\">\n      <h3>Strategy Details</h3>\n      <ul>\n        <li v-for=\"(option, index) in optionsData\" :key=\"index\">\n          Strike Price: {{ option.strikePrice }}, Type: {{ option.type }},\n          Bid: {{ option.bid }}, Ask: {{ option.ask }}, Long/Short: {{ option.longShort }}\n        </li>\n      </ul>\n      <p><strong>Max Profit:</strong> {{ maxProfit }}</p>\n      <p><strong>Max Loss:</strong> {{ maxLoss }}</p>\n      <p><strong>Break Even Points:</strong></p>\n      <ul>\n        <li v-for=\"(breakEven, index) in breakEvenPoints\" :key=\"index\">\n          {{ breakEven }}\n        </li>\n      </ul>\n    </div>\n  </div>\n</template>\n\n<script>\nimport { Line } from 'vue-chartjs';\n\nexport default {\n  name: 'CodingChallenge',\n  extends: Line,\n  props: {\n    optionsData: {\n      type: Array,\n      required: true\n    }\n  },\n  data() {\n    return {\n      maxProfit: 0,\n      maxLoss: 0,\n      breakEvenPoints: []\n    };\n  },\n  mounted() {\n    this.calculateRiskReward();\n  },\n  methods: {\n    calculateRiskReward() {\n      // Implement logic to calculate max profit, max loss, and break even points\n      let totalPremiumReceived = 0;\n      let totalPremiumPaid = 0;\n\n      this.optionsData.forEach(option => {\n        if (option.longShort === 'long') {\n          totalPremiumPaid += option.ask;\n        } else if (option.longShort === 'short') {\n          totalPremiumReceived += option.bid;\n        }\n      });\n\n      this.maxProfit = totalPremiumReceived.toFixed(2);\n      this.maxLoss = totalPremiumPaid.toFixed(2);\n\n      // Example break even point calculation (replace with your strategy logic)\n      this.breakEvenPoints = [\n        this.optionsData[0].strikePrice - this.optionsData[0].ask,\n        this.optionsData[0].strikePrice + this.optionsData[0].bid\n      ];\n\n      // Render the graph after calculations\n      this.renderGraph();\n    },\n    renderGraph() {\n      this.renderChart({\n        labels: ['Underlying Price'],\n        datasets: [{\n          label: 'Profit/Loss',\n          borderColor: 'rgba(75, 192, 192, 1)',\n          borderWidth: 2,\n          pointBackgroundColor: 'rgba(75, 192, 192, 1)',\n          pointBorderColor: '#fff',\n          pointBorderWidth: 1,\n          pointRadius: 3,\n          pointHoverRadius: 5,\n          data: this.calculateProfitLoss()\n        }]\n      }, {\n        responsive: true,\n        maintainAspectRatio: false,\n        scales: {\n          xAxes: [{\n            scaleLabel: {\n              display: true,\n              labelString: 'Underlying Price'\n            },\n            ticks: {\n              beginAtZero: false\n            }\n          }],\n          yAxes: [{\n            scaleLabel: {\n              display: true,\n              labelString: 'Profit/Loss'\n            },\n            ticks: {\n              beginAtZero: false\n            }\n          }]\n        }\n      });\n    },\n    calculateProfitLoss() {\n      // Example logic to calculate profit/loss at different prices\n      const underlyingPrices = [90, 95, 100, 105, 110, 115, 120]; // Example underlying prices\n      const profitLoss = [];\n\n      underlyingPrices.forEach(price => {\n        let totalProfitLoss = 0;\n\n        this.optionsData.forEach(option => {\n          if (option.type === 'Call') {\n            if (option.longShort === 'long') {\n              totalProfitLoss -= Math.max(0, price - option.strikePrice) - option.ask;\n            } else if (option.longShort === 'short') {\n              totalProfitLoss += Math.max(0, price - option.strikePrice) - option.bid;\n            }\n          } else if (option.type === 'Put') {\n            if (option.longShort === 'long') {\n              totalProfitLoss += Math.max(0, option.strikePrice - price) - option.ask;\n            } else if (option.longShort === 'short') {\n              totalProfitLoss -= Math.max(0, option.strikePrice - price) - option.bid;\n            }\n          }\n        });\n\n        profitLoss.push(totalProfitLoss.toFixed(2));\n      });\n\n      return profitLoss;\n    }\n  }\n};\n</script>\n\n<style scoped>\n.coding-challenge {\n  max-width: 800px;\n  margin: 0 auto;\n  padding: 20px;\n  border: 1px solid #ccc;\n  border-radius: 5px;\n  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n}\n\n.graph-container {\n  margin-bottom: 20px;\n}\n\n.strategy-details {\n  border-top: 1px solid #ccc;\n  padding-top: 20px;\n  margin-top: 20px;\n}\n\n.strategy-details h3 {\n  margin-bottom: 10px;\n}\n</style>\n"],"mappings":";AA2BA,SAAAA,IAAA;AAEA;EACAC,IAAA;EACAC,OAAA,EAAAF,IAAA;EACAG,KAAA;IACAC,WAAA;MACAC,IAAA,EAAAC,KAAA;MACAC,QAAA;IACA;EACA;EACAC,KAAA;IACA;MACAC,SAAA;MACAC,OAAA;MACAC,eAAA;IACA;EACA;EACAC,QAAA;IACA,KAAAC,mBAAA;EACA;EACAC,OAAA;IACAD,oBAAA;MACA;MACA,IAAAE,oBAAA;MACA,IAAAC,gBAAA;MAEA,KAAAZ,WAAA,CAAAa,OAAA,CAAAC,MAAA;QACA,IAAAA,MAAA,CAAAC,SAAA;UACAH,gBAAA,IAAAE,MAAA,CAAAE,GAAA;QACA,WAAAF,MAAA,CAAAC,SAAA;UACAJ,oBAAA,IAAAG,MAAA,CAAAG,GAAA;QACA;MACA;MAEA,KAAAZ,SAAA,GAAAM,oBAAA,CAAAO,OAAA;MACA,KAAAZ,OAAA,GAAAM,gBAAA,CAAAM,OAAA;;MAEA;MACA,KAAAX,eAAA,IACA,KAAAP,WAAA,IAAAmB,WAAA,QAAAnB,WAAA,IAAAgB,GAAA,EACA,KAAAhB,WAAA,IAAAmB,WAAA,QAAAnB,WAAA,IAAAiB,GAAA,CACA;;MAEA;MACA,KAAAG,WAAA;IACA;IACAA,YAAA;MACA,KAAAC,WAAA;QACAC,MAAA;QACAC,QAAA;UACAC,KAAA;UACAC,WAAA;UACAC,WAAA;UACAC,oBAAA;UACAC,gBAAA;UACAC,gBAAA;UACAC,WAAA;UACAC,gBAAA;UACA3B,IAAA,OAAA4B,mBAAA;QACA;MACA;QACAC,UAAA;QACAC,mBAAA;QACAC,MAAA;UACAC,KAAA;YACAC,UAAA;cACAC,OAAA;cACAC,WAAA;YACA;YACAC,KAAA;cACAC,WAAA;YACA;UACA;UACAC,KAAA;YACAL,UAAA;cACAC,OAAA;cACAC,WAAA;YACA;YACAC,KAAA;cACAC,WAAA;YACA;UACA;QACA;MACA;IACA;IACAT,oBAAA;MACA;MACA,MAAAW,gBAAA;MACA,MAAAC,UAAA;MAEAD,gBAAA,CAAA9B,OAAA,CAAAgC,KAAA;QACA,IAAAC,eAAA;QAEA,KAAA9C,WAAA,CAAAa,OAAA,CAAAC,MAAA;UACA,IAAAA,MAAA,CAAAb,IAAA;YACA,IAAAa,MAAA,CAAAC,SAAA;cACA+B,eAAA,IAAAC,IAAA,CAAAC,GAAA,IAAAH,KAAA,GAAA/B,MAAA,CAAAK,WAAA,IAAAL,MAAA,CAAAE,GAAA;YACA,WAAAF,MAAA,CAAAC,SAAA;cACA+B,eAAA,IAAAC,IAAA,CAAAC,GAAA,IAAAH,KAAA,GAAA/B,MAAA,CAAAK,WAAA,IAAAL,MAAA,CAAAG,GAAA;YACA;UACA,WAAAH,MAAA,CAAAb,IAAA;YACA,IAAAa,MAAA,CAAAC,SAAA;cACA+B,eAAA,IAAAC,IAAA,CAAAC,GAAA,IAAAlC,MAAA,CAAAK,WAAA,GAAA0B,KAAA,IAAA/B,MAAA,CAAAE,GAAA;YACA,WAAAF,MAAA,CAAAC,SAAA;cACA+B,eAAA,IAAAC,IAAA,CAAAC,GAAA,IAAAlC,MAAA,CAAAK,WAAA,GAAA0B,KAAA,IAAA/B,MAAA,CAAAG,GAAA;YACA;UACA;QACA;QAEA2B,UAAA,CAAAK,IAAA,CAAAH,eAAA,CAAA5B,OAAA;MACA;MAEA,OAAA0B,UAAA;IACA;EACA;AACA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}